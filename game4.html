<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GAME3 - TETRIS</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:#0f1724;
    --accent:#4fc3f7;
    --muted:#94a3b8;
    --tile-0: #0b1020;
    --tile-1: #00f0f0;
    --tile-2: #0000f0;
    --tile-3: #f0a000;
    --tile-4: #f0f000;
    --tile-5: #00f000;
    --tile-6: #a000f0;
    --tile-7: #f00000;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#02030a);font-family:Inter,system-ui,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo, sans-serif;color:#e6eef8}
  .wrap{display:flex;gap:20px;align-items:flex-start;justify-content:center;padding:28px}
  .board {
    background:linear-gradient(180deg,var(--panel),#071026);
    padding:14px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,.6);
  }
  canvas{display:block;background:linear-gradient(180deg,#071428,#02101a);border-radius:6px}
  .side {
    width:220px;
    display:flex;flex-direction:column;gap:12px;
  }
  .info {
    background:linear-gradient(180deg,#071428,#02101a);
    padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);
  }
  .info h2{margin:0 0 8px 0;font-size:18px;color:var(--accent)}
  .stat{display:flex;justify-content:space-between;font-size:18px;color:var(--muted);margin:6px 0}
  .nextCanvas{background:#06121a;border-radius:6px;padding:8px}
  .controls{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}
  .btn{background:linear-gradient(180deg,#1b2b3a,#0f1b28);color:#e6eef8;padding:10px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);cursor:pointer;user-select:none}
  .btn:active{transform:translateY(1px)}
  .big{font-size:18px;padding:12px 16px}
  .hud{display:flex;gap:8px;align-items:center}
  #gameover{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(2,6,23,0.95);padding:28px;border-radius:12px;display:none;text-align:center;z-index:40}
  #gameover h1{margin:0;color:#ff6b6b;font-size:36px}
  #gameover p{color:var(--muted);margin:8px 0 16px 0}
  .footer{position:fixed;left:12px;bottom:12px;color:var(--muted);font-size:13px}
  .touch-controls{display:none;position:fixed;left:0;right:0;bottom:8px;justify-content:center;gap:12px;z-index:30}
  .touch-controls .btn{padding:14px 18px;font-size:18px}
  @media (max-width:900px){
    .wrap{flex-direction:column;align-items:center;padding:12px}
    .side{width:100%;max-width:420px}
    .touch-controls{display:flex}
  }
</style>
</head>
<body>

<div class="wrap">
  <div class="board">
    <canvas id="game" width="240" height="480"></canvas>
  </div>

  <div class="side">
    <div class="info">
      <h2>GAME3 — TETRIS</h2>
      <div class="stat"><span>Score</span><strong id="score">0</strong></div>
      <div class="stat"><span>Level</span><strong id="level">1</strong></div>
      <div class="stat"><span>Lines</span><strong id="lines">0</strong></div>
    </div>

    <div class="info">
      <h2>Next</h2>
      <div class="nextCanvas"><canvas id="next" width="120" height="120"></canvas></div>
    </div>

    <div class="info hud">
      <button id="startBtn" type="button" class="btn big">Start</button>
      <button id="restartBtn" type="button" class="btn big">Restart</button>
    </div>

    <div class="info">
      <h2>Controls</h2>
      <div style="color:var(--muted);font-size:14px;line-height:1.6">
        ← → : move &nbsp; ↑ / X / Z : rotate &nbsp; Space : hard drop &nbsp; ↓ : soft drop
      </div>
    </div>
  </div>
</div>

<div id="gameover">
  <h1>GAME OVER</h1>
  <p id="finalScore">SCORE: 0</p>
  <div style="display:flex;gap:10px;justify-content:center">
    <button id="goRetry" type="button" class="btn big">Retry</button>
    <button id="goTitle" type="button" class="btn big">Title</button>
  </div>
</div>

<!-- mobile touch -->
<div class="touch-controls">
  <button class="btn" id="t-left" type="button">◀</button>
  <button class="btn" id="t-rotate" type="button">⤴</button>
  <button class="btn" id="t-right" type="button">▶</button>
  <button class="btn" id="t-drop" type="button">↓</button>
  <button class="btn" id="t-hard" type="button">⤒</button>
</div>

<div class="footer">Made with ❤️ — GAME3</div>

<script>
/* TETRIS - simple but robust implementation */
(() => {
  const COLS = 10, ROWS = 20;
  const BLOCK = 24;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  canvas.width = COLS * BLOCK;
  canvas.height = ROWS * BLOCK;

  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const gameoverEl = document.getElementById('gameover');
  const finalScoreEl = document.getElementById('finalScore');

  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const goRetry = document.getElementById('goRetry');
  const goTitle = document.getElementById('goTitle');

  const SHAPES = {
    I: [
      [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]
    ],
    J: [
      [[2,0,0],[2,2,2],[0,0,0]],
      [[0,2,2],[0,2,0],[0,2,0]],
      [[0,0,0],[2,2,2],[0,0,2]],
      [[0,2,0],[0,2,0],[2,2,0]]
    ],
    L: [
      [[0,0,3],[3,3,3],[0,0,0]],
      [[0,3,0],[0,3,0],[0,3,3]],
      [[0,0,0],[3,3,3],[3,0,0]],
      [[3,3,0],[0,3,0],[0,3,0]]
    ],
    O: [
      [[4,4],[4,4]]
    ],
    S: [
      [[0,5,5],[5,5,0],[0,0,0]],
      [[0,5,0],[0,5,5],[0,0,5]]
    ],
    T: [
      [[0,6,0],[6,6,6],[0,0,0]],
      [[0,6,0],[0,6,6],[0,6,0]],
      [[0,0,0],[6,6,6],[0,6,0]],
      [[0,6,0],[6,6,0],[0,6,0]]
    ],
    Z: [
      [[7,7,0],[0,7,7],[0,0,0]],
      [[0,0,7],[0,7,7],[0,7,0]]
    ]
  };

  const COLORS = {
    0: getComputedStyle(document.documentElement).getPropertyValue('--tile-0').trim(),
    1: getComputedStyle(document.documentElement).getPropertyValue('--tile-1').trim(),
    2: getComputedStyle(document.documentElement).getPropertyValue('--tile-2').trim(),
    3: getComputedStyle(document.documentElement).getPropertyValue('--tile-3').trim(),
    4: getComputedStyle(document.documentElement).getPropertyValue('--tile-4').trim(),
    5: getComputedStyle(document.documentElement).getPropertyValue('--tile-5').trim(),
    6: getComputedStyle(document.documentElement).getPropertyValue('--tile-6').trim(),
    7: getComputedStyle(document.documentElement).getPropertyValue('--tile-7').trim()
  };

  let grid, current, nextPiece, dropCounter, dropInterval, lastTime, score, level, lines, running;

  function createGrid() {
    const g = [];
    for (let r=0;r<ROWS;r++){
      g.push(new Array(COLS).fill(0));
    }
    return g;
  }

  function randomPiece() {
    const keys = Object.keys(SHAPES);
    const k = keys[Math.floor(Math.random()*keys.length)];
    const rotations = SHAPES[k];
    const rotIndex = 0;
    return {
      name: k,
      matrix: cloneMatrix(rotations[rotIndex]),
      rotIndex,
      rotations,
      x: Math.floor((COLS - rotations[rotIndex][0].length)/2),
      y: - (rotations[rotIndex].length)
    };
  }

  function cloneMatrix(m){
    return m.map(row => row.slice());
  }

  function rotate(piece, dir=1){
    const len = piece.rotations.length;
    piece.rotIndex = (piece.rotIndex + dir + len) % len;
    piece.matrix = cloneMatrix(piece.rotations[piece.rotIndex]);
  }

  function collide(grid, piece){
    const m = piece.matrix;
    for (let y=0;y<m.length;y++){
      for (let x=0;x<m[y].length;x++){
        if (m[y][x]){
          const gx = piece.x + x;
          const gy = piece.y + y;
          if (gy >= 0){
            if (gx < 0 || gx >= COLS || gy >= ROWS) return true;
            if (grid[gy][gx]) return true;
          }
        }
      }
    }
    return false;
  }

  function merge(grid, piece){
    const m = piece.matrix;
    for (let y=0;y<m.length;y++){
      for (let x=0;x<m[y].length;x++){
        if (m[y][x]){
          const gx = piece.x + x;
          const gy = piece.y + y;
          if (gy >= 0 && gy < ROWS && gx >=0 && gx < COLS){
            grid[gy][gx] = m[y][x];
          }
        }
      }
    }
  }

  function clearLines(){
    let rowCount = 0;
    outer: for (let y=ROWS-1;y>=0;y--){
      for (let x=0;x<COLS;x++){
        if (!grid[y][x]) continue outer;
      }
      grid.splice(y,1);
      grid.unshift(new Array(COLS).fill(0));
      rowCount++;
      y++;
    }
    if (rowCount>0){
      const points = [0,40,100,300,1200];
      score += (points[rowCount] * level);
      lines += rowCount;
      level = Math.floor(lines / 10) + 1;
      dropInterval = Math.max(200, 800 - (level-1)*60);
      updateHUD();
    }
  }

  function updateHUD(){
    scoreEl.textContent = score;
    levelEl.textContent = level;
    linesEl.textContent = lines;
  }

  function drawCell(x,y,val,ctxRef){
    const px = x * BLOCK;
    const py = y * BLOCK;
    ctxRef.fillStyle = COLORS[val] || COLORS[0];
    ctxRef.fillRect(px+1,py+1,BLOCK-2,BLOCK-2);
    ctxRef.strokeStyle = 'rgba(0,0,0,0.25)';
    ctxRef.strokeRect(px+1,py+1,BLOCK-2,BLOCK-2);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        if (grid[y][x]){
          drawCell(x,y,grid[y][x],ctx);
        }
      }
    }

    const m = current.matrix;
    for (let y=0;y<m.length;y++){
      for (let x=0;x<m[y].length;x++){
        if (m[y][x]){
          const gx = current.x + x;
          const gy = current.y + y;
          if (gy >= 0){
            drawCell(gx,gy,m[y][x],ctx);
          }
        }
      }
    }

    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    for (let x=0;x<=COLS;x++){
      ctx.beginPath();ctx.moveTo(x*BLOCK,0);ctx.lineTo(x*BLOCK,ROWS*BLOCK);ctx.stroke();
    }
    for (let y=0;y<=ROWS;y++){
      ctx.beginPath();ctx.moveTo(0,y*BLOCK);ctx.lineTo(COLS*BLOCK,y*BLOCK);ctx.stroke();
    }
  }

  function drawNext(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    const m = nextPiece.matrix;
    const cell = Math.floor(nextCanvas.width / 6);
    const offsetX = Math.floor((nextCanvas.width - m[0].length*cell)/2);
    const offsetY = Math.floor((nextCanvas.height - m.length*cell)/2);
    for (let y=0;y<m.length;y++){
      for (let x=0;x<m[y].length;x++){
        if (m[y][x]){
          nctx.fillStyle = COLORS[m[y][x]];
          nctx.fillRect(offsetX + x*cell + 2, offsetY + y*cell + 2, cell-4, cell-4);
          nctx.strokeStyle = 'rgba(0,0,0,0.25)';
          nctx.strokeRect(offsetX + x*cell + 2, offsetY + y*cell + 2, cell-4, cell-4);
        }
      }
    }
  }

  function spawn(){
    current = nextPiece || randomPiece();
    nextPiece = randomPiece();
    current.x = Math.floor((COLS - current.matrix[0].length)/2);
    current.y = - current.matrix.length;
    if (collide(grid,current)){
      gameOver();
    }
    drawNext();
  }

  function drop(){
    current.y++;
    if (collide(grid,current)){
      current.y--;
      merge(grid,current);
      clearLines();
      spawn();
    }
    dropCounter = 0;
  }

  function hardDrop(){
    while(!collide(grid,current)){
      current.y++;
    }
    current.y--;
    merge(grid,current);
    clearLines();
    spawn();
    dropCounter = 0;
  }

  function move(dir){
    current.x += dir;
    if (collide(grid,current)) current.x -= dir;
  }

  function rotatePiece(dir=1){
    const oldIndex = current.rotIndex;
    rotate(current,dir);
    const kicks = [0, -1, 1, -2, 2];
    let kicked = false;
    for (let k of kicks){
      current.x += k;
      if (!collide(grid,current)){ kicked = true; break; }
      current.x -= k;
    }
    if (!kicked){
      current.rotIndex = oldIndex;
      current.matrix = cloneMatrix(current.rotations[oldIndex]);
    }
  }

  let keyState = {};
  document.addEventListener('keydown', e=>{
    if (!running) return;
    if (e.repeat) return;
    keyState[e.code] = true;
    switch(e.code){
      case 'ArrowLeft': move(-1); break;
      case 'ArrowRight': move(1); break;
      case 'ArrowDown':
        current.y++;
        if (collide(grid,current)) current.y--;
        break;
      case 'ArrowUp':
      case 'KeyX':
      case 'KeyZ':
        rotatePiece(1); break;
      case 'Space':
        hardDrop(); break;
    }
    draw();
  });

  document.addEventListener('keyup', e=>{
    keyState[e.code] = false;
  });

  const tLeft = document.getElementById('t-left');
  const tRight = document.getElementById('t-right');
  const tRotate = document.getElementById('t-rotate');
  const tDrop = document.getElementById('t-drop');
  const tHard = document.getElementById('t-hard');

  tLeft.addEventListener('touchstart', e=>{ e.preventDefault(); move(-1); draw(); });
  tRight.addEventListener('touchstart', e=>{ e.preventDefault(); move(1); draw(); });
  tRotate.addEventListener('touchstart', e=>{ e.preventDefault(); rotatePiece(1); draw(); });
  tDrop.addEventListener('touchstart', e=>{ e.preventDefault(); current.y++; if (collide(grid,current)) current.y--; draw(); });
  tHard.addEventListener('touchstart', e=>{ e.preventDefault(); hardDrop(); draw(); });

  function update(time=0){
    if (!running) return;
    const delta = time - lastTime;
    lastTime = time;
    dropCounter += delta;
    if (dropCounter > dropInterval){
      drop();
    }
    draw();
    requestAnimationFrame(update);
  }

  function reset(){
    grid = createGrid();
    nextPiece = randomPiece();
    current = null;
    score = 0; lines = 0; level = 1;
    dropInterval = 800;
    dropCounter = 0;
    lastTime = 0;
    running = false;
    updateHUD();
    draw();
    drawNext();
    gameoverEl.style.display = 'none';
  }

  function start(){
    reset();
    spawn();
    running = true;
    gameoverEl.style.display = 'none';
    lastTime = performance.now();
    requestAnimationFrame(update);
  }

  function gameOver(){
    running = false;
    gameoverEl.style.display = 'block';
    finalScoreEl.textContent = 'SCORE: ' + score;
  }

  startBtn.addEventListener('click', ()=>{ start(); });
  restartBtn.addEventListener('click', ()=>{ start(); });
  goRetry.addEventListener('click', ()=>{ start(); });
  goTitle.addEventListener('click', ()=>{ location.href = 'index.html'; });

  reset();
  draw();

  // expose for debugging
  window.tetris = { start, reset };
})();
</script>

</body>
</html>
