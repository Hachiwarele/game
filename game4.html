<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Guideline Tetris Complete</title>
<style>
body{
  margin:0;
  background:#8BAC0F;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
  font-family:monospace;
  overflow:hidden;
}
#container{
  background:#9BBC0F;
  padding:15px;
  border:8px solid #0F380F;
  border-radius:20px;
  text-align:center;
}
canvas{
  background:#306230;
  border:4px solid #0F380F;
}
#ui{
  margin-top:10px;
  color:#0F380F;
  font-size:18px;
}
</style>
</head>
<body>

<div id="container">
<canvas id="game"></canvas>
<div id="ui">
Score: <span id="score">0</span><br>
Level: <span id="level">1</span><br>
Lines: <span id="lines">0</span>
</div>
</div>

<script>
const COLS=10, ROWS=20, SIZE=30;
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
canvas.width=COLS*SIZE;
canvas.height=ROWS*SIZE;

let board=[...Array(ROWS)].map(()=>Array(COLS).fill(0));

let score=0, level=1, totalLines=0;
let combo=-1, backToBack=false;
let lastRotate=false;

const SHAPES={
I:[
[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
[[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]],
[[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],
[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]
],
O:[
[[1,1],[1,1]],
[[1,1],[1,1]],
[[1,1],[1,1]],
[[1,1],[1,1]]
],
T:[
[[0,1,0],[1,1,1],[0,0,0]],
[[0,1,0],[0,1,1],[0,1,0]],
[[0,0,0],[1,1,1],[0,1,0]],
[[0,1,0],[1,1,0],[0,1,0]]
],
J:[
[[1,0,0],[1,1,1],[0,0,0]],
[[0,1,1],[0,1,0],[0,1,0]],
[[0,0,0],[1,1,1],[0,0,1]],
[[0,1,0],[0,1,0],[1,1,0]]
],
L:[
[[0,0,1],[1,1,1],[0,0,0]],
[[0,1,0],[0,1,0],[0,1,1]],
[[0,0,0],[1,1,1],[1,0,0]],
[[1,1,0],[0,1,0],[0,1,0]]
],
S:[
[[0,1,1],[1,1,0],[0,0,0]],
[[0,1,0],[0,1,1],[0,0,1]],
[[0,0,0],[0,1,1],[1,1,0]],
[[1,0,0],[1,1,0],[0,1,0]]
],
Z:[
[[1,1,0],[0,1,1],[0,0,0]],
[[0,0,1],[0,1,1],[0,1,0]],
[[0,0,0],[1,1,0],[0,1,1]],
[[0,1,0],[1,1,0],[1,0,0]]
]
};

const JLSTZ_KICKS={
"0>1":[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
"1>0":[[0,0],[1,0],[1,-1],[0,2],[1,2]],
"1>2":[[0,0],[1,0],[1,-1],[0,2],[1,2]],
"2>1":[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
"2>3":[[0,0],[1,0],[1,1],[0,-2],[1,-2]],
"3>2":[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
"3>0":[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
"0>3":[[0,0],[1,0],[1,1],[0,-2],[1,-2]]
};

const I_KICKS={
"0>1":[[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
"1>0":[[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
"1>2":[[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
"2>1":[[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
"2>3":[[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
"3>2":[[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
"3>0":[[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
"0>3":[[0,0],[-1,0],[2,0],[-1,2],[2,-1]]
};

let bag=[];
function nextBag(){
 if(bag.length===0){
  bag=Object.keys(SHAPES);
  bag.sort(()=>Math.random()-0.5);
 }
 return bag.pop();
}

let piece, holdPiece=null, canHold=true;
let dropCounter=0, lockCounter=0, lockMoves=0;

function spawn(){
 piece={type:nextBag(),x:3,y:0,rot:0};
 canHold=true;
 lockCounter=0;
 lockMoves=0;
 if(collide()) resetGame();
}

function collide(nx=piece.x,ny=piece.y,nr=piece.rot){
 return SHAPES[piece.type][nr].some((row,y)=>
  row.some((v,x)=>{
   if(!v) return false;
   let px=nx+x, py=ny+y;
   return px<0||px>=COLS||py>=ROWS||board[py]?.[px];
  })
 );
}

function rotate(dir){
 let old=piece.rot;
 let next=(piece.rot+dir+4)%4;
 let kicks=(piece.type==="I"?I_KICKS:JLSTZ_KICKS)[old+">"+next];
 for(let [dx,dy] of kicks){
  if(!collide(piece.x+dx,piece.y-dy,next)){
   piece.x+=dx;
   piece.y-=dy;
   piece.rot=next;
   lastRotate=true;
   resetLock();
   return;
  }
 }
}

function resetLock(){
 if(lockMoves<15){
  lockCounter=0;
  lockMoves++;
 }
}

function merge(){
 SHAPES[piece.type][piece.rot].forEach((r,y)=>
  r.forEach((v,x)=>{
   if(v) board[piece.y+y][piece.x+x]=1;
  })
 );
}

function isTSpin(lines){
 if(piece.type!=="T"||!lastRotate) return false;
 let cx=piece.x+1, cy=piece.y+1;
 let corners=0;
 [[0,0],[2,0],[0,2],[2,2]].forEach(([dx,dy])=>{
  let x=cx-1+dx, y=cy-1+dy;
  if(x<0||x>=COLS||y>=ROWS||board[y]?.[x]) corners++;
 });
 return corners>=3;
}

function clearLines(){
 let lines=0;
 for(let y=ROWS-1;y>=0;y--){
  if(board[y].every(v=>v)){
   board.splice(y,1);
   board.unshift(Array(COLS).fill(0));
   lines++;
   y++;
  }
 }

 if(lines===0){combo=-1;return;}

 totalLines+=lines;
 combo++;

 let tspin=isTSpin(lines);
 let base=0;

 if(tspin){
  if(lines===1) base=800;
  if(lines===2) base=1200;
  if(lines===3) base=1600;
 }else{
  if(lines===1) base=100;
  if(lines===2) base=300;
  if(lines===3) base=500;
  if(lines===4) base=800;
 }

 if((lines===4||tspin)&&backToBack) base*=1.5;
 backToBack=(lines===4||tspin);

 score+=base*level;
 if(combo>0) score+=combo*50*level;

 level=Math.floor(totalLines/10)+1;
}

function hardDrop(){
 let dist=0;
 while(!collide(piece.x,piece.y+1,piece.rot)){
  piece.y++;
  dist++;
 }
 score+=dist*2;
 merge();
 clearLines();
 spawn();
}

function hold(){
 if(!canHold) return;
 if(!holdPiece){
  holdPiece=piece.type;
  spawn();
 }else{
  [piece.type,holdPiece]=[holdPiece,piece.type];
  piece.x=3; piece.y=0; piece.rot=0;
 }
 canHold=false;
}

function drawBlock(x,y,a=1){
 ctx.globalAlpha=a;
 ctx.fillStyle="#0F380F";
 ctx.fillRect(x,y,SIZE,SIZE);
 ctx.strokeStyle="#306230";
 ctx.strokeRect(x,y,SIZE,SIZE);
 ctx.globalAlpha=1;
}

function draw(){
 ctx.clearRect(0,0,canvas.width,canvas.height);

 board.forEach((r,y)=>r.forEach((v,x)=>{
  if(v) drawBlock(x*SIZE,y*SIZE);
 }));

 let ghostY=piece.y;
 while(!collide(piece.x,ghostY+1,piece.rot)) ghostY++;

 SHAPES[piece.type][piece.rot].forEach((r,y)=>
  r.forEach((v,x)=>{
   if(v) drawBlock((piece.x+x)*SIZE,(ghostY+y)*SIZE,0.3);
  })
 );

 SHAPES[piece.type][piece.rot].forEach((r,y)=>
  r.forEach((v,x)=>{
   if(v) drawBlock((piece.x+x)*SIZE,(piece.y+y)*SIZE);
  })
 );

 document.getElementById("score").textContent=score;
 document.getElementById("level").textContent=level;
 document.getElementById("lines").textContent=totalLines;
}

function update(){
 lastRotate=false;
 dropCounter++;
 if(dropCounter>Math.max(5,60-(level-1)*5)){
  if(!collide(piece.x,piece.y+1,piece.rot)){
   piece.y++;
  }else{
   lockCounter++;
   if(lockCounter>30){
    merge();
    clearLines();
    spawn();
   }
  }
  dropCounter=0;
 }
 draw();
 requestAnimationFrame(update);
}

document.addEventListener("keydown",e=>{
 if(e.key==="ArrowLeft"&&!collide(piece.x-1,piece.y,piece.rot)){piece.x--;resetLock();}
 if(e.key==="ArrowRight"&&!collide(piece.x+1,piece.y,piece.rot)){piece.x++;resetLock();}
 if(e.key==="ArrowDown"&&!collide(piece.x,piece.y+1,piece.rot)){piece.y++;score++;}
 if(e.key==="ArrowUp")rotate(1);
 if(e.key==="z")rotate(-1);
 if(e.key==="a")rotate(2);
 if(e.key===" ")hardDrop();
 if(e.key==="Shift")hold();
});

function resetGame(){
 board=[...Array(ROWS)].map(()=>Array(COLS).fill(0));
 score=0; level=1; totalLines=0;
 combo=-1; backToBack=false;
 spawn();
}

spawn();
update();
</script>
</body>
</html>
